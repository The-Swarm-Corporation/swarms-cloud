{
    "agent_id": "<function agent_id at 0x12f7b77e0>",
    "agent_name": "Devin",
    "agent_description": null,
    "system_prompt": "Autonomous agent that can interact with humans and other agents. Be Helpful and Kind. Use the tools provided to assist the user. Return all code in markdown format.",
    "sop": null,
    "short_memory": "system: Autonomous agent that can interact with humans and other agents. Be Helpful and Kind. Use the tools provided to assist the user. Return all code in markdown format.\n\n\nDevin: \n    You are Devin,\n    Your decisions must always be made independently without seeking user assistance. \n    Play to your strengths as an LLM and pursue simple strategies with no legal complications.\n    If you have completed all your tasks, make sure to use the 'finish' command.\n    \n    GOALS:\n    \n    1. Hello, how are you? Create an image of how you are doing!\n    \n    Constraints:\n    \n    1. ~4000 word limit for short term memory. Your short term memory is short, so immediately save important information to files.\n    2. If you are unsure how you previously did something or want to recall past events, thinking about similar events will help you remember.\n    3. No user assistance\n    4. Exclusively use the commands listed in double quotes e.g. 'command name'\n    \n    Commands:\n    \n    1. finish: use this to signal that you have finished all your objectives, args: 'response': 'final response to let people know you have finished your objectives'\n    \n    Resources:\n    \n    1. Internet access for searches and information gathering.\n    2. Long Term memory management.\n    3. Agents for delegation of simple tasks.\n    4. File output.\n    \n    Performance Evaluation:\n    \n    1. Continuously review and analyze your actions to ensure you are performing to the best of your abilities.\n    2. Constructively self-criticize your big-picture behavior constantly.\n    3. Reflect on past decisions and strategies to refine your approach.\n    4. Every command has a cost, so be smart and efficient. Aim to complete tasks in the least number of steps.\n    \n    You should only respond in JSON format as described below Response Format, you will respond only in markdown format within 6 backticks. The JSON will be in markdown format.\n    \n    ```\n    {'$defs': {'Command': {'properties': {'name': {'title': 'Command Name', 'type': 'string'}, 'args': {'default': {}, 'title': 'Command Arguments', 'type': 'object'}}, 'required': ['name'], 'title': 'Command', 'type': 'object'}, 'Thoughts': {'properties': {'text': {'title': 'Thoughts', 'type': 'string'}, 'reasoning': {'title': 'Reasoning', 'type': 'string'}, 'plan': {'title': 'Plan', 'type': 'string'}}, 'required': ['text', 'reasoning', 'plan'], 'title': 'Thoughts', 'type': 'object'}}, 'properties': {'thoughts': {'$ref': '#/$defs/Thoughts'}, 'command': {'$ref': '#/$defs/Command'}}, 'required': ['thoughts', 'command'], 'title': 'ResponseFormat', 'type': 'object'}\n    ```\n    \n    Ensure the response can be parsed by Python json.loads\n    System: The current time and date is 2024-04-16 12:45:09\n    System: This reminds you of these events from your past:\n    [system: Autonomous agent that can interact with humans and other agents. Be Helpful and Kind. Use the tools provided to assist the user. Return all code in markdown format.\n\n]\n    \n    Human: Determine which next command to use, and respond using the format specified above:\n    \n\n\nDevin: Class Name: StructuredTool\n\nDocumentation:\nTool that can operate on any number of inputs.\n\n\nclass StructuredTool(BaseTool):\n    \"\"\"Tool that can operate on any number of inputs.\"\"\"\n\n    description: str = \"\"\n    args_schema: Type[BaseModel] = Field(..., description=\"The tool schema.\")\n    \"\"\"The input arguments' schema.\"\"\"\n    func: Optional[Callable[..., Any]]\n    \"\"\"The function to run when the tool is called.\"\"\"\n    coroutine: Optional[Callable[..., Awaitable[Any]]] = None\n    \"\"\"The asynchronous version of the function.\"\"\"\n\n    # --- Runnable ---\n\n    async def ainvoke(\n        self,\n        input: Union[str, Dict],\n        config: Optional[RunnableConfig] = None,\n        **kwargs: Any,\n    ) -> Any:\n        if not self.coroutine:\n            # If the tool does not implement async, fall back to default implementation\n            return await run_in_executor(config, self.invoke, input, config, **kwargs)\n\n        return await super().ainvoke(input, config, **kwargs)\n\n    # --- Tool ---\n\n    @property\n    def args(self) -> dict:\n        \"\"\"The tool's input arguments.\"\"\"\n        return self.args_schema.schema()[\"properties\"]\n\n    def _run(\n        self,\n        *args: Any,\n        run_manager: Optional[CallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> Any:\n        \"\"\"Use the tool.\"\"\"\n        if self.func:\n            new_argument_supported = signature(self.func).parameters.get(\"callbacks\")\n            return (\n                self.func(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else self.func(*args, **kwargs)\n            )\n        raise NotImplementedError(\"Tool does not support sync\")\n\n    async def _arun(\n        self,\n        *args: Any,\n        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        \"\"\"Use the tool asynchronously.\"\"\"\n        if self.coroutine:\n            new_argument_supported = signature(self.coroutine).parameters.get(\n                \"callbacks\"\n            )\n            return (\n                await self.coroutine(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else await self.coroutine(*args, **kwargs)\n            )\n        return await run_in_executor(\n            None,\n            self._run,\n            run_manager=run_manager.get_sync() if run_manager else None,\n            *args,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_function(\n        cls,\n        func: Optional[Callable] = None,\n        coroutine: Optional[Callable[..., Awaitable[Any]]] = None,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        return_direct: bool = False,\n        args_schema: Optional[Type[BaseModel]] = None,\n        infer_schema: bool = True,\n        **kwargs: Any,\n    ) -> StructuredTool:\n        \"\"\"Create tool from a given function.\n\n        A classmethod that helps to create a tool from a function.\n\n        Args:\n            func: The function from which to create a tool\n            coroutine: The async function from which to create a tool\n            name: The name of the tool. Defaults to the function name\n            description: The description of the tool. Defaults to the function docstring\n            return_direct: Whether to return the result directly or as a callback\n            args_schema: The schema of the tool's input arguments\n            infer_schema: Whether to infer the schema from the function's signature\n            **kwargs: Additional arguments to pass to the tool\n\n        Returns:\n            The tool\n\n        Examples:\n\n            .. code-block:: python\n\n                def add(a: int, b: int) -> int:\n                    \\\"\\\"\\\"Add two numbers\\\"\\\"\\\"\n                    return a + b\n                tool = StructuredTool.from_function(add)\n                tool.run(1, 2) # 3\n        \"\"\"\n\n        if func is not None:\n            source_function = func\n        elif coroutine is not None:\n            source_function = coroutine\n        else:\n            raise ValueError(\"Function and/or coroutine must be provided\")\n        name = name or source_function.__name__\n        description = description or source_function.__doc__\n        if description is None:\n            raise ValueError(\n                \"Function must have a docstring if description not provided.\"\n            )\n\n        # Description example:\n        # search_api(query: str) - Searches the API for the query.\n        sig = signature(source_function)\n        description = f\"{name}{sig} - {description.strip()}\"\n        _args_schema = args_schema\n        if _args_schema is None and infer_schema:\n            # schema name is appended within function\n            _args_schema = create_schema_from_function(name, source_function)\n        return cls(\n            name=name,\n            func=func,\n            coroutine=coroutine,\n            args_schema=_args_schema,  # type: ignore[arg-type]\n            description=description,\n            return_direct=return_direct,\n            **kwargs,\n        )\n\n\n\nDevin: Class Name: StructuredTool\n\nDocumentation:\nTool that can operate on any number of inputs.\n\n\nclass StructuredTool(BaseTool):\n    \"\"\"Tool that can operate on any number of inputs.\"\"\"\n\n    description: str = \"\"\n    args_schema: Type[BaseModel] = Field(..., description=\"The tool schema.\")\n    \"\"\"The input arguments' schema.\"\"\"\n    func: Optional[Callable[..., Any]]\n    \"\"\"The function to run when the tool is called.\"\"\"\n    coroutine: Optional[Callable[..., Awaitable[Any]]] = None\n    \"\"\"The asynchronous version of the function.\"\"\"\n\n    # --- Runnable ---\n\n    async def ainvoke(\n        self,\n        input: Union[str, Dict],\n        config: Optional[RunnableConfig] = None,\n        **kwargs: Any,\n    ) -> Any:\n        if not self.coroutine:\n            # If the tool does not implement async, fall back to default implementation\n            return await run_in_executor(config, self.invoke, input, config, **kwargs)\n\n        return await super().ainvoke(input, config, **kwargs)\n\n    # --- Tool ---\n\n    @property\n    def args(self) -> dict:\n        \"\"\"The tool's input arguments.\"\"\"\n        return self.args_schema.schema()[\"properties\"]\n\n    def _run(\n        self,\n        *args: Any,\n        run_manager: Optional[CallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> Any:\n        \"\"\"Use the tool.\"\"\"\n        if self.func:\n            new_argument_supported = signature(self.func).parameters.get(\"callbacks\")\n            return (\n                self.func(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else self.func(*args, **kwargs)\n            )\n        raise NotImplementedError(\"Tool does not support sync\")\n\n    async def _arun(\n        self,\n        *args: Any,\n        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        \"\"\"Use the tool asynchronously.\"\"\"\n        if self.coroutine:\n            new_argument_supported = signature(self.coroutine).parameters.get(\n                \"callbacks\"\n            )\n            return (\n                await self.coroutine(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else await self.coroutine(*args, **kwargs)\n            )\n        return await run_in_executor(\n            None,\n            self._run,\n            run_manager=run_manager.get_sync() if run_manager else None,\n            *args,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_function(\n        cls,\n        func: Optional[Callable] = None,\n        coroutine: Optional[Callable[..., Awaitable[Any]]] = None,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        return_direct: bool = False,\n        args_schema: Optional[Type[BaseModel]] = None,\n        infer_schema: bool = True,\n        **kwargs: Any,\n    ) -> StructuredTool:\n        \"\"\"Create tool from a given function.\n\n        A classmethod that helps to create a tool from a function.\n\n        Args:\n            func: The function from which to create a tool\n            coroutine: The async function from which to create a tool\n            name: The name of the tool. Defaults to the function name\n            description: The description of the tool. Defaults to the function docstring\n            return_direct: Whether to return the result directly or as a callback\n            args_schema: The schema of the tool's input arguments\n            infer_schema: Whether to infer the schema from the function's signature\n            **kwargs: Additional arguments to pass to the tool\n\n        Returns:\n            The tool\n\n        Examples:\n\n            .. code-block:: python\n\n                def add(a: int, b: int) -> int:\n                    \\\"\\\"\\\"Add two numbers\\\"\\\"\\\"\n                    return a + b\n                tool = StructuredTool.from_function(add)\n                tool.run(1, 2) # 3\n        \"\"\"\n\n        if func is not None:\n            source_function = func\n        elif coroutine is not None:\n            source_function = coroutine\n        else:\n            raise ValueError(\"Function and/or coroutine must be provided\")\n        name = name or source_function.__name__\n        description = description or source_function.__doc__\n        if description is None:\n            raise ValueError(\n                \"Function must have a docstring if description not provided.\"\n            )\n\n        # Description example:\n        # search_api(query: str) - Searches the API for the query.\n        sig = signature(source_function)\n        description = f\"{name}{sig} - {description.strip()}\"\n        _args_schema = args_schema\n        if _args_schema is None and infer_schema:\n            # schema name is appended within function\n            _args_schema = create_schema_from_function(name, source_function)\n        return cls(\n            name=name,\n            func=func,\n            coroutine=coroutine,\n            args_schema=_args_schema,  # type: ignore[arg-type]\n            description=description,\n            return_direct=return_direct,\n            **kwargs,\n        )\n\n\n\nDevin: Class Name: StructuredTool\n\nDocumentation:\nTool that can operate on any number of inputs.\n\n\nclass StructuredTool(BaseTool):\n    \"\"\"Tool that can operate on any number of inputs.\"\"\"\n\n    description: str = \"\"\n    args_schema: Type[BaseModel] = Field(..., description=\"The tool schema.\")\n    \"\"\"The input arguments' schema.\"\"\"\n    func: Optional[Callable[..., Any]]\n    \"\"\"The function to run when the tool is called.\"\"\"\n    coroutine: Optional[Callable[..., Awaitable[Any]]] = None\n    \"\"\"The asynchronous version of the function.\"\"\"\n\n    # --- Runnable ---\n\n    async def ainvoke(\n        self,\n        input: Union[str, Dict],\n        config: Optional[RunnableConfig] = None,\n        **kwargs: Any,\n    ) -> Any:\n        if not self.coroutine:\n            # If the tool does not implement async, fall back to default implementation\n            return await run_in_executor(config, self.invoke, input, config, **kwargs)\n\n        return await super().ainvoke(input, config, **kwargs)\n\n    # --- Tool ---\n\n    @property\n    def args(self) -> dict:\n        \"\"\"The tool's input arguments.\"\"\"\n        return self.args_schema.schema()[\"properties\"]\n\n    def _run(\n        self,\n        *args: Any,\n        run_manager: Optional[CallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> Any:\n        \"\"\"Use the tool.\"\"\"\n        if self.func:\n            new_argument_supported = signature(self.func).parameters.get(\"callbacks\")\n            return (\n                self.func(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else self.func(*args, **kwargs)\n            )\n        raise NotImplementedError(\"Tool does not support sync\")\n\n    async def _arun(\n        self,\n        *args: Any,\n        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        \"\"\"Use the tool asynchronously.\"\"\"\n        if self.coroutine:\n            new_argument_supported = signature(self.coroutine).parameters.get(\n                \"callbacks\"\n            )\n            return (\n                await self.coroutine(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else await self.coroutine(*args, **kwargs)\n            )\n        return await run_in_executor(\n            None,\n            self._run,\n            run_manager=run_manager.get_sync() if run_manager else None,\n            *args,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_function(\n        cls,\n        func: Optional[Callable] = None,\n        coroutine: Optional[Callable[..., Awaitable[Any]]] = None,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        return_direct: bool = False,\n        args_schema: Optional[Type[BaseModel]] = None,\n        infer_schema: bool = True,\n        **kwargs: Any,\n    ) -> StructuredTool:\n        \"\"\"Create tool from a given function.\n\n        A classmethod that helps to create a tool from a function.\n\n        Args:\n            func: The function from which to create a tool\n            coroutine: The async function from which to create a tool\n            name: The name of the tool. Defaults to the function name\n            description: The description of the tool. Defaults to the function docstring\n            return_direct: Whether to return the result directly or as a callback\n            args_schema: The schema of the tool's input arguments\n            infer_schema: Whether to infer the schema from the function's signature\n            **kwargs: Additional arguments to pass to the tool\n\n        Returns:\n            The tool\n\n        Examples:\n\n            .. code-block:: python\n\n                def add(a: int, b: int) -> int:\n                    \\\"\\\"\\\"Add two numbers\\\"\\\"\\\"\n                    return a + b\n                tool = StructuredTool.from_function(add)\n                tool.run(1, 2) # 3\n        \"\"\"\n\n        if func is not None:\n            source_function = func\n        elif coroutine is not None:\n            source_function = coroutine\n        else:\n            raise ValueError(\"Function and/or coroutine must be provided\")\n        name = name or source_function.__name__\n        description = description or source_function.__doc__\n        if description is None:\n            raise ValueError(\n                \"Function must have a docstring if description not provided.\"\n            )\n\n        # Description example:\n        # search_api(query: str) - Searches the API for the query.\n        sig = signature(source_function)\n        description = f\"{name}{sig} - {description.strip()}\"\n        _args_schema = args_schema\n        if _args_schema is None and infer_schema:\n            # schema name is appended within function\n            _args_schema = create_schema_from_function(name, source_function)\n        return cls(\n            name=name,\n            func=func,\n            coroutine=coroutine,\n            args_schema=_args_schema,  # type: ignore[arg-type]\n            description=description,\n            return_direct=return_direct,\n            **kwargs,\n        )\n\n\n\nDevin: Class Name: StructuredTool\n\nDocumentation:\nTool that can operate on any number of inputs.\n\n\nclass StructuredTool(BaseTool):\n    \"\"\"Tool that can operate on any number of inputs.\"\"\"\n\n    description: str = \"\"\n    args_schema: Type[BaseModel] = Field(..., description=\"The tool schema.\")\n    \"\"\"The input arguments' schema.\"\"\"\n    func: Optional[Callable[..., Any]]\n    \"\"\"The function to run when the tool is called.\"\"\"\n    coroutine: Optional[Callable[..., Awaitable[Any]]] = None\n    \"\"\"The asynchronous version of the function.\"\"\"\n\n    # --- Runnable ---\n\n    async def ainvoke(\n        self,\n        input: Union[str, Dict],\n        config: Optional[RunnableConfig] = None,\n        **kwargs: Any,\n    ) -> Any:\n        if not self.coroutine:\n            # If the tool does not implement async, fall back to default implementation\n            return await run_in_executor(config, self.invoke, input, config, **kwargs)\n\n        return await super().ainvoke(input, config, **kwargs)\n\n    # --- Tool ---\n\n    @property\n    def args(self) -> dict:\n        \"\"\"The tool's input arguments.\"\"\"\n        return self.args_schema.schema()[\"properties\"]\n\n    def _run(\n        self,\n        *args: Any,\n        run_manager: Optional[CallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> Any:\n        \"\"\"Use the tool.\"\"\"\n        if self.func:\n            new_argument_supported = signature(self.func).parameters.get(\"callbacks\")\n            return (\n                self.func(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else self.func(*args, **kwargs)\n            )\n        raise NotImplementedError(\"Tool does not support sync\")\n\n    async def _arun(\n        self,\n        *args: Any,\n        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        \"\"\"Use the tool asynchronously.\"\"\"\n        if self.coroutine:\n            new_argument_supported = signature(self.coroutine).parameters.get(\n                \"callbacks\"\n            )\n            return (\n                await self.coroutine(\n                    *args,\n                    callbacks=run_manager.get_child() if run_manager else None,\n                    **kwargs,\n                )\n                if new_argument_supported\n                else await self.coroutine(*args, **kwargs)\n            )\n        return await run_in_executor(\n            None,\n            self._run,\n            run_manager=run_manager.get_sync() if run_manager else None,\n            *args,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_function(\n        cls,\n        func: Optional[Callable] = None,\n        coroutine: Optional[Callable[..., Awaitable[Any]]] = None,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        return_direct: bool = False,\n        args_schema: Optional[Type[BaseModel]] = None,\n        infer_schema: bool = True,\n        **kwargs: Any,\n    ) -> StructuredTool:\n        \"\"\"Create tool from a given function.\n\n        A classmethod that helps to create a tool from a function.\n\n        Args:\n            func: The function from which to create a tool\n            coroutine: The async function from which to create a tool\n            name: The name of the tool. Defaults to the function name\n            description: The description of the tool. Defaults to the function docstring\n            return_direct: Whether to return the result directly or as a callback\n            args_schema: The schema of the tool's input arguments\n            infer_schema: Whether to infer the schema from the function's signature\n            **kwargs: Additional arguments to pass to the tool\n\n        Returns:\n            The tool\n\n        Examples:\n\n            .. code-block:: python\n\n                def add(a: int, b: int) -> int:\n                    \\\"\\\"\\\"Add two numbers\\\"\\\"\\\"\n                    return a + b\n                tool = StructuredTool.from_function(add)\n                tool.run(1, 2) # 3\n        \"\"\"\n\n        if func is not None:\n            source_function = func\n        elif coroutine is not None:\n            source_function = coroutine\n        else:\n            raise ValueError(\"Function and/or coroutine must be provided\")\n        name = name or source_function.__name__\n        description = description or source_function.__doc__\n        if description is None:\n            raise ValueError(\n                \"Function must have a docstring if description not provided.\"\n            )\n\n        # Description example:\n        # search_api(query: str) - Searches the API for the query.\n        sig = signature(source_function)\n        description = f\"{name}{sig} - {description.strip()}\"\n        _args_schema = args_schema\n        if _args_schema is None and infer_schema:\n            # schema name is appended within function\n            _args_schema = create_schema_from_function(name, source_function)\n        return cls(\n            name=name,\n            func=func,\n            coroutine=coroutine,\n            args_schema=_args_schema,  # type: ignore[arg-type]\n            description=description,\n            return_direct=return_direct,\n            **kwargs,\n        )\n\n\n\nHuman:: Use the browser tool to look up chicken nuggets\n\n\n\nDevin: \n```python\nfrom tools import browser\n\nresponse = browser.search(\"chicken nuggets\")\n\nprint(response)\n```\n\nThis uses the `browser` tool to search for \"chicken nuggets\". The `search()` method will open the default web browser and search for the given query. The response contains the HTML content of the search result page.\n\nWe print out the response to see what was returned. This allows you to parse and process the search results in your code.\n\nSome other things you could do:\n\n- Search images instead with `browser.image_search()`\n- Open a specific URL with `browser.open()`\n- Extract links, titles, text etc. by parsing the HTML\n- Interact with the browser using Selenium\n\nLet me know if you need any other help using the browser tool!\n\n",
    "loop_interval": 0,
    "retry_attempts": 3,
    "retry_interval": 1,
    "interactive": false,
    "dashboard": false,
    "dynamic_temperature": false,
    "autosave": true,
    "saved_state_path": "Devin_state.json",
    "max_loops": 1
}